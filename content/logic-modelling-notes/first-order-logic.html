<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
    <script type="text/javascript" async src="https://cdn.jsdelivr.net/gh/mathjax/MathJax@2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
    <link rel="Stylesheet" type="text/css" href="style.css" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        document.querySelectorAll('pre.code').forEach(function(item) {
          hljs.highlightBlock(item)
        })
      });
    </script>
    <title>first-order-logic</title>
</head>
<body>
<style type="text/css">
nav a {
    text-align: left;
}
nav #name {
    text-align: right;
    float: right;
    font-style: italic;
}
</style>
    <nav>
    <a href="index.html">Index</a>
    <span id="name">Alex Balgavy</span>
    </nav>
    <hr>
    <div class="content">
    
<div id="First order logic"><h2 id="First order logic" class="header"><a href="#First order logic">First order logic</a></h2></div>
<div id="First order logic-Functions, predicates, relations"><h3 id="Functions, predicates, relations" class="header"><a href="#First order logic-Functions, predicates, relations">Functions, predicates, relations</a></h3></div>
<p>
functions: take different numbers of arguments, returns a result. e.g. \(mul(x,y)\), \(square(x)\)
</p>

<p>
predicates, relations: takes one or more arguments, is either true or false. e.g. \(even(x)\), \(divides(x,y)\)
</p>

<p>
formulas: say things. make assertions about objects in the domain.
</p>

<div id="First order logic-Quantifiers, binding"><h3 id="Quantifiers, binding" class="header"><a href="#First order logic-Quantifiers, binding">Quantifiers, binding</a></h3></div>
<p>
Quantifiers:
</p>
<ul>
<li>
∀x: "for all x"

<li>
∃x: "there exists an x"

</ul>

<p>
Generally bind tightly: ∀x P ∨ Q == (∀x P) ∨ Q
</p>

<p>
free variable: variable that's not bound
</p>

<p>
sentence: a formula that has no free variables
</p>

<div id="First order logic-Quantifiers, binding-Natural deduction rules"><h4 id="Natural deduction rules" class="header"><a href="#First order logic-Quantifiers, binding-Natural deduction rules">Natural deduction rules</a></h4></div>

<table>
<tr>
<th>
Universal quantification
</th>
<th>
Existential quantification
</th>
<th>
Equality
</th>
</tr>
<tr>
<td>
<img src="img/universal-introduction.png" alt="Universal introduction" />
</td>
<td>
<img src="img/existential-introduction.png" alt="Existential introduction" />
</td>
<td rowspan="2">
<img src="img/equality-rules.png" alt="Equality rules" />
</td>
</tr>
<tr>
<td>
<img src="img/universal-elimination.png" alt="Universal elimination" />
</td>
<td>
<img src="img/existential-elimination.png" alt="Existential elimination" />
</td>
</tr>
</table>


<div id="First order logic-Relativization and sorts"><h3 id="Relativization and sorts" class="header"><a href="#First order logic-Relativization and sorts">Relativization and sorts</a></h3></div>
<p>
You can use implication to relativize quantification (put it into a specific domain).
</p>

<p>
Universal quantification, e.g. "every prime number greater than two is odd":
</p>

<p>
∀x (prime(x) ∧ x &gt; 2 → odd(x))
</p>

<p>
Existential quantification, e.g. "some woman is strong":
</p>

<p>
∃x (woman(x) ∧ strong(x))
</p>

<p>
Remember to use ∧ with ∃, and not →.
</p>

<div id="First order logic-Models"><h3 id="Models" class="header"><a href="#First order logic-Models">Models</a></h3></div>
<p>
Let F be a set of function symbols, P a set of predicate symbols.
</p>

<p>
Model M for (F, P) consists of:
</p>
<ul>
<li>
non-empty set A ("domain", "universe")

<li>
interpretation operation \((\cdot)^M\) for for symbols in F, P

</ul>

<p>
Universe A can be any non-empty set.
</p>

<p>
only constraint: \(F^M\) and \(P^M\) have same number of arguments as F and P.
</p>

<div id="First order logic-Interpreting formulas without quantifiers"><h3 id="Interpreting formulas without quantifiers" class="header"><a href="#First order logic-Interpreting formulas without quantifiers">Interpreting formulas without quantifiers</a></h3></div>
<p>
Truth definition for formula Φ without quantifiers and free variables in model M by induction on the structure of Φ:
</p>
<ul>
<li>
M ⊨ ¬Φ ↔ not: M ⊨ Φ ↔ M ⊭ Φ

<li>
M ⊨ Æ∧ Ψ ↔ M ⊨ Φ and M ⊨ Ψ

<li>
M ⊨ Φ ∨ Ψ ↔ M ⊨ Φ or M ⊨ Ψ

<li>
M ⊨ Φ → Ψ : if M ⊨ Φ then M ⊨ Ψ

<li>
M ⊨ P(t₁, .., tn) ↔ (\(t_1^M,\ldots,t_n^M) \in P^M\)

</ul>

<p>
Interpretation of terms \(t^M\):
</p>
<ul>
<li>
if t = c for constant c, then \(t^M = c^M\)

<li>
if \(t = f(t_1,\ldots, t_n)\), then \(t^M = f^M(t_1^M,\ldots,t_n^M)\)

</ul>

<div id="First order logic-Interpretation of formulas with quantifiers and free variables"><h3 id="Interpretation of formulas with quantifiers and free variables" class="header"><a href="#First order logic-Interpretation of formulas with quantifiers and free variables">Interpretation of formulas with quantifiers and free variables</a></h3></div>
<p>
to interpret free variables, you use an environment.
</p>

<p>
an environment <code>l: var → A</code> (look up function) interprets free variables in the domain
</p>

<div id="First order logic-Interpreting terms in model with environment"><h3 id="Interpreting terms in model with environment" class="header"><a href="#First order logic-Interpreting terms in model with environment">Interpreting terms in model with environment</a></h3></div>
<p>
terms are built from variables, constants, function symbols
</p>
<ul>
<li>
variables are interpreted according to environment

<li>
constants are interpreted according to \((\cdot)^M\)

<li>
function symbols are interpreted according to \((\cdot)^M\)

</ul>


<p>
Truth of formula Φ in model M with universe A with respect to environment e is defined by induction on the structure of Φ.
</p>

<p>
Interpretation \(t^{M,l}\) of term t is
</p>

\begin{align}
t^{M, l} = \begin{cases}
            l(x) &amp;&amp;\text{if } t = x \text{ for a variable } x \\
            c^M &amp;&amp;\text{if } t = c \text{ for a constant } c \\
            f^M (t_1^{M, l}, \ldots, t_n^{M, l}) &amp;&amp;\text{if } t = f(t_1, \ldots, t_n)
            \end{cases}
\end{align}
<p>
by induction on term structure.
</p>

<p>
M ⊨l ∀x HI ↔ for all a ∈ A it holds that \( M \models_{l [x \to a]} \phi \)
</p>

<p>
M ⊨l ∃x Φ ↔ for some a ∈ A it holds that \( M \models_{l [x \to a]} \phi \)
</p>

<div id="First order logic-Semantical entailment in predicate logic"><h3 id="Semantical entailment in predicate logic" class="header"><a href="#First order logic-Semantical entailment in predicate logic">Semantical entailment in predicate logic</a></h3></div>
<p>
For all models M and all environments e,
such that M ⊨l Φ₁ and ... and M ⊨l Φn hold,
it also holds that M ⊨l ψ
</p>

<div id="First order logic-Logical equivalence"><h3 id="Logical equivalence" class="header"><a href="#First order logic-Logical equivalence">Logical equivalence</a></h3></div>
<p>
Formulas φ and ψ are logically equivalent (φ ≡ ψ) if for all models M and environments l, M ⊨l φ ↔ M ⊨l ψ
</p>

<p>
i.e. φ and ψ are true in precisely the same models when interpreted with the same environments.
</p>

<p>
theorem: φ ≡ ψ  ↔ φ ⊨ ψ and ψ ⊨ φ
</p>

<div id="First order logic-Satisfiability, validity, consistency"><h3 id="Satisfiability, validity, consistency" class="header"><a href="#First order logic-Satisfiability, validity, consistency">Satisfiability, validity, consistency</a></h3></div>
<p>
Let φ be a formula, and Γ be a set of formulas.
</p>

<p>
φ is satisfiable iff there is <em>some</em> model M and <em>some</em> environment l such that M ⊨l φ
</p>

<p>
φ is valid iff M ⊨l φ holds for <em>all</em> models M and <em>all</em> environments l in which φ can be checked.
</p>

<p>
Γ is consistent/satisfiable iff there is <em>some</em> model M and <em>some</em> environment l such tat M ⊨l ψ for all ψ ∈ Γ
</p>

<p>
for all formulas φ, ψ: φ ≡ ψ means that φ ↔ ψ is valid
</p>

<div id="First order logic-Translating into predicate logic"><h3 id="Translating into predicate logic" class="header"><a href="#First order logic-Translating into predicate logic">Translating into predicate logic</a></h3></div>
<p>
Example: "Marie and Jan are clever."
</p>

<p>
Specification and model used:
</p>

<p>
two predicates:
</p>
<ul>
<li>
CC(x): x is clever

<li>
LL(x): x has learned logic

</ul>

<p>
two constants:
</p>
<ul>
<li>
m: Marie

<li>
j: Jan

</ul>

<p>
model M:
</p>
<ul>
<li>
domain A = the set of all humans

<li>
\(C^M\) = { x ∈ A | x is clever }

<li>
\(LL^M\) = { x ∈ A | x has learned logic }

<li>
\(j^M \)= Jan

<li>
\(m^M\) = Marie

</ul>

<p>
Then:
</p>
<ul>
<li>
"Marie and Jan are clever": C(m) ∧ C(j)

<li>
"Not everybody is clever": ¬∀x C(x)

<li>
"Somebody has learned logic": ∃x LL(x)

<li>
"Not everybody has learned logic, but Marie and Jan have": ¬∀x LL(x) ∧ LL(m) ∧ LL(j)

</ul>

<p>
∀ and →:
</p>
<ul>
<li>
∀x(LL(x) → C(x)): "everyone who has learned logic is clever"

<li>
not the same as ∀x LL(x) → ∀x C(x): "if everyone has learned logic, everyone is clever"

</ul>

<p>
∃ and ∧:
</p>
<ul>
<li>
∃x(L(x) ∧ C(x)): "some logicians are clever"

<li>
not the same as ∃x(L(x) → C(x)): "if someone is a logician, they are clever"

</ul>

<p>
Formulas with free variables express properties and relations:
</p>
<ul>
<li>
no free variables: a sentence

<li>
one free variable: a property

<li>
two or more free variables: a relation

</ul>

<div id="First order logic-Rules for quantifiers and connectives"><h3 id="Rules for quantifiers and connectives" class="header"><a href="#First order logic-Rules for quantifiers and connectives">Rules for quantifiers and connectives</a></h3></div>
<p>
If you move a negation around ∀, it becomes ∃, and vice versa.
</p>

<p>
It also holds that:
</p>
<ul>
<li>
∀x(φ ∧ ψ) ≡ ∀x φ ∧ ∀x ψ

<ul>
<li>
BUT in general doesn't hold for ∨

</ul>
<li>
∃x(φ ∨ ψ) ≡ ∃x φ ∨ ∃x ψ

<ul>
<li>
BUT in general doesn't hold for ∧

</ul>
</ul>

<p>
In general, you can't move quantifiers through an implication.
</p>

<p>
Order of <em>repeated</em> ∀ or ∃ doesn't matter. But if you have <em>both</em> ∃ and ∀, the order is important.
</p>

<div id="First order logic-Semantics of first order logic"><h3 id="Semantics of first order logic" class="header"><a href="#First order logic-Semantics of first order logic">Semantics of first order logic</a></h3></div>
<p>
Interpretation: specifying the meaning of a predicate symbol.
</p>
<ul>
<li>
unary predicate P: set of elements of domain D for which P is true.

<li>
constant c: an element of domain D

<li>
function f with arity n: function mapping n elements of domain D to another element of D

<li>
relation R with arity n: set of n tuples of elements of domain D for which R is true

</ul>

<p>
You can find the truth value of sentences intuitively.
</p>

<p>
Completeness: if formula A is logical consequence of set of sentences Γ, then A is provable from Γ.
</p>

<p>
Soundness: if A is provable from Γ then A is true in any model of Γ
</p>

    </div>
</body>
</html>
