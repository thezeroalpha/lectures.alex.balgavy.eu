<!DOCTYPE html>
<html>
<head>
<script type="text/javascript" async src="https://cdn.jsdelivr.net/gh/mathjax/MathJax@2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>logical-agents</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<div id="Logical agents"><h1 id="Logical agents">Logical agents</h1></div>

<div id="Logical agents-What is logic"><h2 id="What is logic">What is logic</h2></div>
<p>
logic: generic method to deal with partial/imperfect/implicit information
</p>

<p>
we need:
</p>
<ul>
<li>
syntax to write statement about rules &amp; knowledge of the game (a language)

<li>
semantics to say what legal expressions mean, the meaning of each sentence with respect to interpretations

<li>
calculus for how to determine meaning for legal expressions

</ul>

<p>
knowledge-based/logical agents must be able to:
</p>
<ul>
<li>
represent states &amp; actions

<li>
incorporate new percepts, update internal representation of world

<li>
deduce hidden properties of the world &amp; appropriate actions

</ul>

<p>
online/exploratory search: go to position, evaluate all options, possibly look ahead. have to re-evaluate current position.
</p>

<div id="Logical agents-Syntax"><h2 id="Syntax">Syntax</h2></div>
<div id="Logical agents-Syntax-Propositional logic (PL)"><h3 id="Propositional logic (PL)">Propositional logic (PL)</h3></div>
<p>
assumes world contains facts
</p>

<p>
uses proposition symbols to state these facts.
</p>

<p>
pros:
</p>
<ul>
<li>
declarative

<li>
allows partial/disjunctive/negated information

<li>
is compositional

<li>
meaning of statements is context-independent

</ul>

<p>
cons:
</p>
<ul>
<li>
very limited expressive power

</ul>

<div id="Logical agents-Syntax-First order logic (FOL)"><h3 id="First order logic (FOL)">First order logic (FOL)</h3></div>
<p>
an extension of propositional logic.
</p>

<p>
allows variables to range over atomic symbols in the domain.
</p>

<p>
assumes world contains:
</p>
<ul>
<li>
objects: people, houses, colors, baseball games, etc.

<li>
relations: red, round, prime, brother of, comes between, bigger than, etc.

<li>
functions: father of, best friend, one more than, plus, etc.  

</ul>

<div id="Logical agents-Syntax-First order logic (FOL)-Basic elements:"><h4 id="Basic elements:">Basic elements:</h4></div>
<ul>
<li>
Constants: KingJohn, 2, UCB, ...

<li>
Predicates: Brother, &gt;, ...

<li>
Functions: Sqrt, LeftLegOf, ...

<li>
Variables: x, y, ...

<li>
Connectives: ∧, ∨, ¬, ⇒, ⇔

</ul>

<div id="Logical agents-Syntax-First order logic (FOL)-Sentences"><h4 id="Sentences">Sentences</h4></div>
<pre>
Atomic sentence = predicate (term_1,..., term_n)
                  or term_1 = term_2
Term = function(term_1,..., term_n)
      or constant 
      or variable
</pre>

<p>
Complex sentences are made from atomic sentences using connectives.
</p>

<div id="Logical agents-Syntax-First order logic (FOL)-Quantification"><h4 id="Quantification">Quantification</h4></div>
<div id="Logical agents-Syntax-First order logic (FOL)-Quantification-Universal quantification"><h5 id="Universal quantification">Universal quantification</h5></div>
<p>
∀ &lt;variables&gt; &lt;sentence&gt;
</p>

<p>
∀x P is true in a model <em>m</em> iff P is true with x being each possible object in the model
</p>

<p>
(you can roughly translate that to conjunctions) 
</p>

<p>
typically used with ⇒
</p>

<p>
<span id="Logical agents-Syntax-First order logic (FOL)-Quantification-Universal quantification-CARE:"></span><strong id="CARE:">CARE:</strong> ∀x ∀y ≠ ∀y ∀x
</p>

<div id="Logical agents-Syntax-First order logic (FOL)-Quantification-Existential quantification"><h5 id="Existential quantification">Existential quantification</h5></div>
<p>
∃ &lt;variables&gt; &lt;sentence&gt;
</p>

<p>
∃x P is true in a model <em>m</em> iff P is true with x being some possible object in the model
</p>

<p>
(you can roughly translate that to disjunction of instantiations of P)
</p>

<p>
typically used with ∧
</p>

<p>
watch out, if you use it with ⇒, it works even if the LHS is false!
</p>

<p>
<span id="Logical agents-Syntax-First order logic (FOL)-Quantification-Existential quantification-CARE"></span><strong id="CARE">CARE</strong>: ∃x ∃y ≠ ∃y ∃x
</p>

<div id="Logical agents-Syntax-First order logic (FOL)-Quantification-Quantifier Duality"><h5 id="Quantifier Duality">Quantifier Duality</h5></div>
<p>
each quantifier can be expressed in terms of the other
</p>

<p>
e.g. these are the same:
</p>
<ul>
<li>
∀x Likes(x, IceCream) -- "everyone likes ice cream"

<li>
¬∃x ¬Likes(x, IceCream) -- "there is nobody who doesn't like ice cream"

</ul>

<div id="Logical agents-Syntax-First order logic (FOL)-Decidability vs undecidability"><h4 id="Decidability vs undecidability">Decidability vs undecidability</h4></div>
<p>
undecidability
</p>
<ul>
<li>
Turing machine can calculate everything that can be calculated

<li>
halting problem: \(K := { (i,x) | \text{program i halts when run on input x})\)

</ul>

<p>
decidability
</p>
<ul>
<li>
validity of FOL is not decidable (but semi-decidable)

<li>
if a theorem is logically entailed by an axiom, you can prove that it is.

<li>
if not, you can't necessarily prove that it's not (because you can continue with your proof infinitely).

</ul>

<div id="Logical agents-Syntax-First order logic (FOL)-Knowledge engineering in FOL"><h4 id="Knowledge engineering in FOL">Knowledge engineering in FOL</h4></div>
<ol>
<li>
Identify the task

<li>
Assemble relevant knowledge

<li>
Decide on vocabulary of predicates, functions, and constants

<li>
Encode general knowledge about the domain (terms that we want to use)

<li>
Encode description of the specific problem instance

<li>
Pose queries to the inference procedure and get answers

</ol>

<div id="Logical agents-Syntax-Choice of formalisms"><h3 id="Choice of formalisms">Choice of formalisms</h3></div>
<p>
first-order logic: represents knowledge
</p>

<p>
propositional logic: used for reasoning ("propositionalisation")
</p>

<p>
then use reasoner to check for entailment of propositional logic knowledge base an decision query
</p>
<ul>
<li>
Davis Putnam (DPLL) algorithm

<li>
formulas have to be in clause normal form (CNF)

<li>
calculus is proof by refutation:

<ul>
<li>
DPLL determines satisfiability of a KB

<li>
entailment of KB |= a by "refutation":

<ul>
<li>
KB |= a if KB ∩ {~a} is unsatisfiable

<li>
assume the opposite and prove it's impossible

</ul>
</ul>
</ul>

<div id="Logical agents-Syntax-Propositionalising FOL"><h3 id="Propositionalising FOL">Propositionalising FOL</h3></div>
<div id="Logical agents-Syntax-Propositionalising FOL-Reduction to propositional inference"><h4 id="Reduction to propositional inference">Reduction to propositional inference</h4></div>
<p>
every FOL KB can be propositionalised so as to preserve entailment
</p>

<p>
if a sentence α is entailed by an FOL KB, it is entailed by a <em>finite</em> subset of the propositionalised KB
</p>

<div id="Logical agents-Syntax-Propositionalising FOL-Universal instantiation (UI):"><h4 id="Universal instantiation (UI):">Universal instantiation (UI):</h4></div>
<p>
every instantiation of a universally quantified sentence is entailed by it.
</p>

<p>
<img src="img/univ-instant.png" alt="Universal instantiation" />
</p>

<p>
example:
</p>
<pre>
∀x King(x) ∧ Greedy(x) ⇒ Evil(x)
King(John) ∧ Greedy(John) ⇒ Evil(John)
etc.
</pre>

<div id="Logical agents-Syntax-Propositionalising FOL-Existential instantiation (EI):"><h4 id="Existential instantiation (EI):">Existential instantiation (EI):</h4></div>
<p>
<img src="img/exist-instant.png" alt="Existential instantiation" />
</p>

<p>
example:
</p>
<pre>
∃x Crown(x) ∧ OnHead(x,John)
Crown(C_1) ∧ OnHead(C_1, John)
</pre>

<div id="Logical agents-Syntax-Propositionalising FOL-Applying in Schnapsen - Strategies (examples)"><h4 id="Applying in Schnapsen - Strategies (examples)">Applying in Schnapsen - Strategies (examples)</h4></div>
<div id="Logical agents-Syntax-Propositionalising FOL-Applying in Schnapsen - Strategies (examples)-Play Jack"><h5 id="Play Jack">Play Jack</h5></div>

<p>
check whether card is a jack: 
</p>

<pre>
KB |= PlayJack(x) ?
</pre>

<p>
represent strategy: 
</p>

<pre>
∀x PlayJack(x) ⇔ Jack(x)
</pre>

<p>
represent game information: 
</p>

<pre>
KB = {Jack(4), Jack(0), Jack(14), Jack(19)}
</pre>

<div id="Logical agents-Syntax-Propositionalising FOL-Applying in Schnapsen - Strategies (examples)-Play cheap"><h5 id="Play cheap">Play cheap</h5></div>
<p>
only play Jacks: check whether card is cheap
</p>

<pre>
KB |= PlayCheap(x) ?
</pre>

<p>
represent strategy:
</p>

<pre>
∀x PlayCheap(x) ⇔ Jack(x) ∨ Queen(x) ∨ King(x)
</pre>
  
<p>
represent game information:
</p>

<pre>
KB = {Jack(4), Jack(9), Jack(14), Jack(19), Queen(5), ...}
</pre>
  
<div id="Logical agents-Syntax-Propositionalising FOL-Applying in Schnapsen - Strategies (examples)-Play trump marriage"><h5 id="Play trump marriage">Play trump marriage</h5></div>
<pre>
TrumpMarriage(x) ⇔ Q(x) &amp; Trump(x) &amp; ∃y: SameColor(x,y) &amp; K(y) &amp; MyCard(y)
SameColor(x,y) ⇔ (C(x) &amp; C(y)) ∨ (D(x) &amp; D(y)) ∨ (H(x) &amp; H(y)) ∨ (S(x) &amp; S(y))
</pre>

<div id="Logical agents-Semantics"><h2 id="Semantics">Semantics</h2></div>
<div id="Logical agents-Semantics-Interpretations &amp; Models"><h3 id="Interpretations &amp; Models">Interpretations &amp; Models</h3></div>
<p>
interpretation: assignment of meaning to symbols of formal language
</p>

<p>
model: interpretation that satisfies defining axioms of knowledge base
</p>

<p>
<em>m</em> is a model of a sentence <em>α</em> if <em>α</em> holds in <em>m</em>.
</p>

<p>
M(a) is the set of all models of a.
</p>

<p>
each model specifies true/false for each proposition symbol (∧, ∨, ¬, ⇒, ⇐, ⇔)
</p>

<div id="Logical agents-Semantics-Entailment"><h3 id="Entailment">Entailment</h3></div>
<p>
the knowledge base (KB) entails <em>α</em>: <em>α</em> follows from the information in the knowledge base (KB |= <em>α</em>)
</p>

<p>
KB entails <em>α</em> iff <em>α</em> holds in all worlds where KB is true.
</p>

<p>
a knowledge base is the rules + observations.
</p>

<p>
a sentence is:
</p>
<ul>
<li>
entailed by KB iff α holds in all models of KB

<li>
valid if it is true in all models

<li>
satisfiable  if it is true in some model

<li>
unsatisfiable if it is true in no models

</ul>

<p>
two statements are logically equivalent if they are true in same set of models:
</p>

<p>
α ≡ β iff α |= β and β |= α
</p>

<div id="Logical agents-Semantics-Truth"><h3 id="Truth">Truth</h3></div>
<p>
sentences are true with respect to model and interpretation.
</p>

<p>
model contains objects and relations among them
</p>

<p>
interpretation specifies referents for:
</p>
<ul>
<li>
constant symbols -- objects

<li>
predicate symbols -- relations

<li>
function symbols -- functional relations

</ul>

<p>
an atomic sentence \(predicate(term_1, ..., term_n)\) is true
iff the objects referred to by \(term_1,..., term_n\)
are in the relation referred to by \(predicate\)
</p>

<div id="Logical agents-Semantics-Validity"><h3 id="Validity">Validity</h3></div>
<p>
valid if it is true in all models.
</p>

<p>
e.g. True, A ∨ ¬A, A ⇒ A, (A ∧ (A e.g. True, A ∨ ⇒ B)) ⇒ B)
</p>

<div id="Logical agents-Semantics-Satisfiability"><h3 id="Satisfiability">Satisfiability</h3></div>
<ul>
<li>
satisfiable if it is true in <em>some</em> model

<li>
unsatisfiable if it is true in <em>no</em> models

</ul>

<div id="Logical agents-Calculus (algorithms for inference)"><h2 id="Calculus (algorithms for inference)">Calculus (algorithms for inference)</h2></div>
<div id="Logical agents-Calculus (algorithms for inference)-Properties of inference"><h3 id="Properties of inference">Properties of inference</h3></div>
<p>
sound: if an algorithm \(|-\) only derives entailed sentences. 
  i.e. if KB \(|-\) α also KB |= α
</p>

<p>
complete: if an algorithm derives any sentence that is entailed. 
  i.e. KB |= α implies KB |- α
</p>

<p>
a calculus terminates if it finds entailed sentences in finite time.
</p>

<p>
a logic is <em>decidable</em> if there is <em>sound and complete</em> calculus that <em>terminates</em>.
</p>

<div id="Logical agents-Calculus (algorithms for inference)-Proof methods"><h3 id="Proof methods">Proof methods</h3></div>
<ol>
<li>
Model checking and search

<ul>
<li>
truth table enumeration (exponential in n)

<li>
improved backtracking (DPLL)

<li>
heuristics for choosing right order

</ul>
<li>
application of inference rules

<ul>
<li>
sound generation of new sentences from old

<li>
proof = sequence of rule applications (actions)

</ul>
</ol>

<div id="Logical agents-Calculus (algorithms for inference)-Proof methods-Model checking &amp; search"><h4 id="Model checking &amp; search">Model checking &amp; search</h4></div>
<div id="Logical agents-Calculus (algorithms for inference)-Proof methods-Model checking &amp; search-Truth Tables for inference"><h5 id="Truth Tables for inference">Truth Tables for inference</h5></div>
<p>
enumerate interpretations and check that where KB is true, α is true.
</p>

<table>
<tr>
<th>
\(fact_1\)
</th>
<th>
\(fact_2\)
</th>
<th>
\(fact_3\)
</th>
<th>
\(KB\)
</th>
<th>
\(α\)
</th>
</tr>
<tr>
<td>
false
</td>
<td>
false
</td>
<td>
false
</td>
<td>
false
</td>
<td>
true
</td>
</tr>
<tr>
<td>
false
</td>
<td>
false
</td>
<td>
false
</td>
<td>
false
</td>
<td>
true
</td>
</tr>
<tr>
<td>
false
</td>
<td>
true
</td>
<td>
false
</td>
<td>
<em>true</em>
</td>
<td>
<em>true</em>
</td>
</tr>
</table>

<p>
algorithm:
</p>

<pre>
for (m in truth assignments) {
  if (m makes F true) return "satisfiable"
}
return "unsatisfiable"
</pre>

<div id="Logical agents-Calculus (algorithms for inference)-Proof methods-Model checking &amp; search-Effective proofs by model checking"><h5 id="Effective proofs by model checking">Effective proofs by model checking</h5></div>

<p>
Clever search (depth first, redundancy, heuristics)
</p>

<p>
Two families of efficient algorithms for propositional inference based on model checking
</p>
<ul>
<li>
complete backtracking search algorithms -- DPLL (Davis, Putnam, Logemann, Loveland)

<li>
incomplete local search algorithm (WalkSAT algorithm)

</ul>

<div id="Logical agents-Calculus (algorithms for inference)-Proof methods-Model checking &amp; search-Clause Normal Form (CNF)"><h5 id="Clause Normal Form (CNF)">Clause Normal Form (CNF)</h5></div>

<p>
memo technique: the C in CNF for <em>conjunction</em> normal form
</p>

<p>
A PL formula is in CNF if it is a conjunction of disjunctions of literals.
</p>
<ul>
<li>
e.g.: {{a,b}, {~a, c}, {~b, c}}

<li>
equivalent to (a ∨ b) ∧ (~ a ∨ c) ∧ (~ b ∨ c)

</ul>

<p>
calculating CNF:
</p>
<ol>
<li>
Remove implications: 

<ul>
<li>
(p ⇔ q) to ((p ⇒ q) ∧ (q ⇒ p))

<li>
(p → q) to (¬ p ∨ q)

</ul>
<li>
Move negations inward: 

<ul>
<li>
¬ (p ∨ q) to (¬ p ∧ ¬ q)

<li>
¬ (p ∧ q) to (¬ p ∨ ¬ q)

</ul>
<li>
Move conjunctions outward:

<ul>
<li>
(r ∨ (p ∧ q)) to ((r ∨ p) ∧ (r ∨ q))

</ul>
<li>
Split up conjunctive clauses:

<ul>
<li>
( (p1 ∨ p2) ∧ (q1 ∨ q2) ) to (p1 ∨ p2), (q1 ∨ q2)

</ul>
</ol>

<div id="Logical agents-Calculus (algorithms for inference)-Proof methods-Model checking &amp; search-DPLL algorithm"><h5 id="DPLL algorithm">DPLL algorithm</h5></div>

<p>
when you have CNF, you can run the DPLL algorithm. determines if propositional logic sentence in CNF is satisfiable.
</p>

<p>
returns true if F is satisfiable, false otherwise.
</p>

<p>
basically assign values until contradiction, then backtrack.
</p>

<p>
Improving DPLL:
</p>
<ul>
<li>
if a literal in a disjunction clause is true, the clause is true

<li>
if a literal in a disjunction clause is false, the literal can be removed

<li>
if a clause is empty, it is false

<li>
a unit literal has to be true

<li>
a pure literal (only appears non-negated) has to be true

</ul>

<p>
the algorithm:
</p>

<pre>
dpll (F, literal) {
  remove clauses containing literal
  shorten clauses containing ¬literal
  if (F contains no clauses) 
    return true
  if (F contains empty clause) 
    return false
  if (F contains a unit or pure literal)
    return dpll(F, literal)
  
  choose P in F
  if (dpll(F, ¬P)) 
    return true
  
  return dpll(F, P)
}
</pre>

<div id="Logical agents-Calculus (algorithms for inference)-Proof methods-Model checking &amp; search-DPLL algorithm-Heuristic search in DPLL"><h6 id="Heuristic search in DPLL">Heuristic search in DPLL</h6></div>

<p>
used in DPLL to select proposition for branching
</p>

<p>
idea: identify most constrained variable, likely to create many unit clauses
</p>

<p>
MOM's heuristic: most occurrences in clauses of minimum length
</p>

<p>
why is it better than truth table enumeration?
</p>
<ul>
<li>
early termination: clause is true if any literal is true. sentence is false if any clause is false.

<li>
pure symbol heuristic: always appears with the same sign in all clauses, has to be true

<li>
unit clause heuristic: only one literal in the clause, so it must be true

</ul>

<p>
proving entailment KB |= a by refutation:
</p>
<ol>
<li>
translate KB into CNF to get cnf(KB)

<li>
translate ~a into CNF to get cnf(~a)

<li>
add cnf(~a) to cnf(KB)

<li>
apply DPLL until either satisfiable (model is found) or unsatisfiable (search exhausted)

<li>
if satisfiable, not entailed. otherwise, entailed.

</ol>

<div id="Logical agents-Calculus (algorithms for inference)-Proof methods-Model checking &amp; search-Satisfiability modulo theory"><h5 id="Satisfiability modulo theory">Satisfiability modulo theory</h5></div>

<p>
Boolean satisfiability (SAT): is there an assignment to the \(p_1, p_2, ..., p_n\) variables such that \(\phi\) evaluates to 1?
</p>

<p>
<img src="img/boolean-satisfiability.png" alt="Boolean satisfiability diagram" />
</p>

<p>
SAT vs SMT:
</p>
<ul>
<li>
SMT (satisfiability modulo theories) extend SAT solving by adding extensions.

<li>
SMT solver can solve SAT problem, but not vice-versa.

<li>
SMT is used in analog circuit verification, RTL, verification, and card games.

</ul>

<p>
SMT theories:
</p>
<ul>
<li>
real or integer arithmetic

<li>
equality and uninterpreted functions

<li>
bit vectors and arrays

<li>
properties:

<ul>
<li>
decidable: an effective procedure exists to determine if formula is member of theory T

<li>
often quantifier-free

</ul>
<li>
core theory:

<ul>
<li>
type boolean

<li>
constants {TRUE, FALSE}

<li>
functions {AND, OR, XOR, =&gt;}

</ul>
<li>
integer theory:

<ul>
<li>
type int

<li>
all numerals are int constants

<li>
functions {+, -, x, mod, div, abs}

</ul>
<li>
reals theory:

<ul>
<li>
type real

<li>
functions {+, -, x, /, &lt;, &gt;}

<li>


</ul>
</ul>
<div id="Logical agents-Calculus (algorithms for inference)-Proof methods-Rule-based reasoning"><h4 id="Rule-based reasoning">Rule-based reasoning</h4></div>
<div id="Logical agents-Calculus (algorithms for inference)-Proof methods-Rule-based reasoning-Inference rules"><h5 id="Inference rules">Inference rules</h5></div>
<p>
inference rule: logical form consisting of function taking premises, analyzing their syntax, and returning one or more conclusions
</p>

<p>
Modens Ponens: \(\frac{\alpha\implies\beta,\;\alpha}{\beta}\)
</p>

<p>
And-elimination: \(\frac{\alpha\land\beta}{\alpha}\)
</p>

<p>
logical equivalences used as rules: \(\frac{\alpha\iff\beta}{(\alpha\implies\beta)\land(\beta\implies\alpha)}\)
</p>

<p>
all logical equivalence rewriting rules:
</p>

<p>
<img src="img/logical-rewriting-rules.png" alt="Rewriting rules for logic" />
</p>

<div id="Logical agents-Calculus (algorithms for inference)-Proof methods-Rule-based reasoning-Searching for proofs"><h5 id="Searching for proofs">Searching for proofs</h5></div>
<p>
Finding proofs is like finding solutions to search problems.
</p>

<p>
monotonicity: set of entailed sentences can only increase as info is added to the knowledge base.
</p>
<ul>
<li>
for any sentence α and β,

<li>
if KB |= α, then KB ∧ β |= α

</ul>

<div id="Logical agents-Calculus (algorithms for inference)-Proof methods-Rule-based reasoning-Forward and backward chaining"><h5 id="Forward and backward chaining">Forward and backward chaining</h5></div>
<p>
FC is data-driven, automatic, unconscious:
</p>
<ul>
<li>
derive all facts entailed by the KB

<li>
may do lots of work irrelevant to the goal

</ul>

<p>
BC is goal-driven, appropriate for problem-solving
</p>
<ul>
<li>
specific fact entailed by the KB

<li>
complexity of BC can be much less than linear in size of KB

</ul>

<div id="Logical agents-Calculus (algorithms for inference)-Proof methods-Rule-based reasoning-Resolution"><h5 id="Resolution">Resolution</h5></div>
<p>
a rule is sound if its conclusion is evaluated to true whenever the premise is evaluated to true.
</p>

<p>
can be shown to be sound using truth table:
</p>

<p>
<img src="img/sound-rules-inference.png" alt="Sound rules for inference" />
</p>

<p>
properties resolution:
</p>
<ul>
<li>
resolution rule is sound

<li>
resolution rule is complete (on its own) for formulas in CNF

<li>
resolution can only decide satisfiability

</ul>

<p>
algorithm (again proof by refutation):
</p>
<ol>
<li>
Convert KB ∧ ¬ α into CNF

<li>
Apply resolution rule to resulting clauses

<li>
Continue until:

<ol>
<li>
no new clauses can be added, hence α does not entail β

<li>
two clauses resolve to entail empty clause, hence α entails β

</ol>
</ol>

</body>
</html>
