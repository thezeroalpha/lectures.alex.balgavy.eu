+++
title = 'Tracking control flow'
+++
# Tracking control flow
Explore execution paths in the program.

Control flow graph (CFG) of each function:
- represent potential flow of control inside function

Call graph
- represent potential flow of control between functions

Basic block: maximal sequence of instructions that execute one-by-one in order

Control flow graph:
- nodes are basic blocks with one entry point and one exit point
- directed edges indicate possible control flow

Call graph
- nodes are functions
- directed edges show potential for one function to invoke another

Identifying a function
- ideally:
    - set a of basic blocks with single entry point
    - reached using a call instruction
    - ends with ret instructions
- in reality, might be reached using jump, might share blocks with other functions, might have multiple entries

## Problems
- Pointer-based control transfer: conditionally set a function pointer, then call function pointer
- non-returning calls: some functions won't return, code following call site may not be valid
- non-contiguous code sections: could have jump tables, data, unparsed code, junk bytes...
- tail calls: `return f(x)`
- gaps in binary: might contain undiscovered functions
- shared code and multiple entry representation

You should:
- run the program multiple times, observe targets of indirect jumps and calls
- look for function prologue sequences (`push %rbp`, `mov %rsp, %rbp`)


