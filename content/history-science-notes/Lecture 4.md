+++
title = "Lecture 4"
+++
# Lecture 4

People started playing with computers to appropriate them.

Appropriating — using it for something other than its purpose (e.g. sound)

Real time computing:

- it was never an obvious thing
- Whirlwind/SAGE
    - project Whirlwind flight simulator (1944)
        - for Jay Forrester from MIT
        - wanted for military training, as universal flight trainer
        - it didn’t work out, took too long
    - SAGE for the same thing
        - IBM, Burroughs, Bell labs
        - learning about core memories, printed circuits, mass storage, programming
        - operaional in 1963, cost $8b
        - but by that time ICBMs were operational
        - at the end was useful for regulating plane traffic, due to cameras
- others: Hewlett SABRE, ATM, UPC
- general ideal of “cashless society” (like Diners club)
    - Barclays cash dispenser in London 1967 — robot cashier
    - credit card system, ATM and VISA
    - universal product code (1973) — barcode
        - this was in the US
        - of course Europe had to make their own, Intl. Product Code (CIPC) in 1974
- Barclays & Burroughs for Decimal Day (Feb 15, 1971)
    - could’ve been IBM, but Burroughs was more British
    - building a B8500 to connect to TC500 terminals
    - took forever, but they managed to sell a nonexistent computer for like 4 million.
    - lots of problems. they were late with delivery, the Burroughs B8500 programmer left...
    - in the end, Barclays went with IBM

Agendas:

- selling machines — for IBM and Burroughs
- academic discipline — Dijkstra wanted it mathematical. cybernetics, logic, sharing, calc.
- thinking machines
- programming: first wires/tapes/punch cards, then FORTRAN/COBOL

Programming:

- language ALGOL60
    - elegant, universal, satisfies European sense of clarity & order
    - but from US point of view, it was too academic, inflexible, and hard to learn. better in theory than in practice. but this was mostly ‘regular’ people in user groups, academics liked it.
    - two issues: make old programs run on new machines, ease of programming
    - multiple working groups: IEEE, SHARE, ...
    - SHARE & IBM decided not to go with it. IFIR did.
    - ACM set it as standard for publication of scientific algorithms
- FORTRAN
    - John Backus, researcher from IBM, produced Formula Translator (FORTRAN) in 1953-1954
    - one statement would produce many machine instructions, giving programmer more power and making shit easier
    - his main point was economic. half of cost of running computer center was salaries for programmers, and "programmign and debugging accounted for as much as three-quarters of the cost of operating a computer”
    - this is why IBM gave him support for developing FORTRAN for the new model 704
    - main aim was efficiency, elegance of language came second.
    - used mathematical formula syntax
    - trying to make a system that could write programs as well as human programmers could
    - it soon became the most widely used programming language, a ‘standard’ for scientific applications
    - it spread organically, “by accident”, and universities and colleges eagerly started teaching and using it
- COBOL
    - Common Business Oriented Language (COBOL) was created as standard by US government.
    - every time the government changed their computers, all programs had to be rewritten, which was expensive and took up time.
    - in 1959, the government sponsored Committee on Data Systems and Languages (CODASYL) to create a new standard language for data processing
    - syntax was very similar to english, so non-programmers (managers, administrators) could still feel like they can understand the programs
    - manufacturers didn’t want to accept it because they liked to be different from others. but then the government decided that it would not lease or buy any new computers without COBOL compilers unless the companies could prove it was useless, and of course nobody did, so everybody started adding COBOL compilers
    - COBOL was taught on blackboards
- companies started providing computer services at start of 60s: maintenance, building/tuning, batch processing
- programming started becoming a job, not just spare time hobby
- software started becoming an economic commodity

## Rise of software industry

in the 60s, a company couldn’t sustain itself just with software, they also needed maintenance, batch processing, building

1968 IBM “Unbundling” — software became separate from hardware

Software crisis as a result:

- IBM/360 was late af, adding programmers simply couldn’t scale it up
- “Hardware developed faster than software developers” is an EU/US agenda, academic, theoretical.
- “Nobody knew ho to write proper code” (important in NL, Dijkstra tried to solve this)
- there is also the “there wasn’t a crisis” POV
- agenda was set by academics
- programmer became a profession, informatics a science