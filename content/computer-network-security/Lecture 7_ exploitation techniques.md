+++
title="Lecture 7: exploitation techniques"
+++

# Lecture 7: exploitation techniques
Buffer overflows:
- common mistake
- can exploit locally and remotely
- can modify both data and control flow
- architecture and OS version dependent
- example buffer overflow was contiguous, arbitrary-length, null-terminated, stack-based. variations in these are possible.
- typical signs of buffer overflows: fixed-length buffers, passing pointer to buffer without size, array access without size check, pointer arithmetic without size/end pointer
- vulnerable functions:
    - `gets()` reads up to newline - replace with `fgets()`
    - `strcpy()`/`strcat()` copies up to null byte - replace with `strncpy()`/`strncat()`
    - `sprintf()` etc. length depends on format arguments - replace with `snprintf()` etc.
    - `scanf()` etc. length depends on input string - put bound on `%s` formats
    - own input functions might be sloppy, always check assumptions

Array overflow example (provides arbitrary write):

```c
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char **argv) {
    long array[8];
    long index = strtol(argv[1], NULL, 10);
    long value = strtoul(argv[2], NULL, 16);
    array[index] = value;
    return 0;
}
```
You can load shellcode into environment, then write to this array to overwrite the return address.