<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><link rel="stylesheet" href="sitewide.css"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.6 (457297)"/><meta name="altitude" content="-4.208271026611328"/><meta name="author" content="Alex Balgavy"/><meta name="created" content="2018-12-19 00:27:28 +0000"/><meta name="latitude" content="52.30035507272927"/><meta name="longitude" content="4.988170104808015"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-12-19 00:27:51 +0000"/><title>Principles of IO software</title></head><body><div style="-en-paragraph:true;"><span style="-en-paragraph:true;">the concepts:</span></div><ul><li><div style="-en-paragraph:true;"><span style="-en-paragraph:true;">device independence:</span></div></li><ul><li><div>IO software provides abstraction over actual hardware</div></li><li><div>programs shouldn't have to care about device particularities</div></li></ul><li><div style="-en-paragraph:true;"><span style="-en-paragraph:true;">uniform naming:</span></div></li><ul><li><div style="-en-paragraph:true;"><span style="-en-paragraph:true;">because if you have to type a unique 20 letter id to access a device you’ll give up</span></div></li></ul><li><div style="-en-paragraph:true;"><span style="-en-paragraph:true;">error handling:</span></div></li><ul><li><div>errors should be handled closest to their source so we don’t have to give a crap</div></li></ul><li><div style="-en-paragraph:true;"><span style="-en-paragraph:true;">synchronous vs asynchronous IO:</span></div></li><ul><li><div>programs don't want to deal with interrupts.</div></li><li><div>so OS turns async operations into blocking operations</div></li><li><div>then lower levels have to deal with interrupts</div></li></ul><li><div style="-en-paragraph:true;"><span style="-en-paragraph:true;">buffering:</span></div></li><ul><li><div>networking: incoming packets have to be buffered</div></li><li><div>audio: buffering to avoid clicks</div></li></ul></ul><div style="-en-paragraph:true;"><br/></div><div style="-en-paragraph:true;"><span style="-en-paragraph:true;">the layers in practice:</span></div><div style="-en-paragraph:true;"><br/></div><div style="-en-paragraph:true;"><img src="Principles%20of%20IO%20software.resources/screenshot.png" height="294" width="653"/></div><div style="-en-paragraph:true;"><br/></div><div style="-en-paragraph:true;"><br/></div><div style="-en-paragraph:true;"><span style="-en-paragraph:true;">interrupt handler</span></div><ul><li><div>device driver doesn't handle low-level interrupt directly</div></li><li><div>lowe-level handler is relatively generic</div></li><li><div>on linux, calls device driver-specific interrupt handler if registered</div></li><li><div>on minix, sends message to device driver that registered for interrupt</div></li></ul><div style="-en-paragraph:true;"><span style="-en-paragraph:true;">device driver:</span></div><ul><li><div>accepts abstract reqs from device-independent layer and transforms them into commands for the device</div></li><li><div>can queue new requests as necessary</div></li><li><div>usually needs to wait for completion of the request (IRQ)</div></li><li><div>checks for errors and answers requests from device-independent layer</div></li></ul><div style="-en-paragraph:true;"><span style="-en-paragraph:true;">device independent IO software:</span></div><ul><li><div>uniform interfacing for device drivers (driver nterface, naming (major/minor numbers), and protection</div></li><li><div>buffering: necessary for both character and block devices</div></li><li><div>error reporting: hardware-level, driver-level, etc.</div></li><li><div>allocing/deallocing dedicated devices (e.g. printers)</div></li><li><div>device-independent block size: unify blocks/characters across devices</div></li></ul><div>user-level IO software</div><ul><li><div>single interface allowing user to access devices</div></li><li><div>in C: fopen, close, fflush, frpintf, and so on</div></li><li><div>safely multiplexes access to exclusive devices</div></li></ul><div><br/></div><div><u><b><br/></b></u></div><div><br/></div></body></html>