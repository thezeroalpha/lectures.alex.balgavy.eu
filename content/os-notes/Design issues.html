<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><link rel="stylesheet" href="sitewide.css"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.6 (457297)"/><meta name="altitude" content="-4.208046913146973"/><meta name="author" content="Alex Balgavy"/><meta name="created" content="2018-12-18 23:51:55 +0000"/><meta name="latitude" content="52.3003418234608"/><meta name="longitude" content="4.988162359396394"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-12-18 23:54:08 +0000"/><title>Design issues</title></head><body><div><span style="font-weight: bold;">Allocation policies:
</span></div><ul><li><div>local allocation:
</div></li><ul><li><div>replaces only pages of current process</div></li><li><div>assumes static process memory allocation size</div></li><li><div>problems:
</div></li><ul><li><div>growing <span style="font-style: italic;">working set</span> leads to <span style="font-style: italic;">trashing</span></div></li><li><div>shrinking working set leads to wasted memory</div></li></ul></ul><li><div>global allocation:
</div></li><ul><li><div>replaces pages owned by any process</div></li><li><div>strategies:
</div></li><ul><li><div>treat every global page equally, or prioritize</div></li><li><div>dynamic memory balancing using working set size estimation</div></li><li><div>selectively swap out processes, i.e. hurt process efficiency since it's not as important (or OOM kill)</div></li></ul></ul></ul><div><br/></div><div><span style="font-weight: bold;">Working set model:
</span></div><ul><li><div>working set estimation:
</div></li><ul><li><div>aging-based</div></li><li><div>scanning-based: like aging, but without temporal dimension. divide time in discrete slots, scan all reference bits in page table entries, decide how many slots</div></li><li><div>active lists (e.g. WSCLOCK): amount of pages in working set is known, want to decide which set of pages is in working set. active list of n elements (size of working set) which contains active pages</div></li><li><div>applications: memory prepaging, page replacement, checkpoint-restore, live migration</div></li></ul><li><div>working set size estimation:
</div></li><ul><li><div>sampling-based</div></li><li><div>monitoring-based (e.g. page fault freq)</div></li><li><div>Miss Rate Curves (MRC)</div></li><li><div>applications: dynamic memory balancing, garbage collection, WS estimation</div></li></ul></ul><div><br/></div><div><span style="font-weight: bold;">Cleaning policy:
</span></div><ul><li><div>paging works well if there are a lot of free pages</div></li><li><div>direct reclaim: when you have the need to allocate new page, you directly reclaim an existing page</div></li><li><div>indirect reclaim: paging daemon sleeps and then evict pages if free pages are in short supply (don't wait until the last minute)</div></li><li><div>another way is to leave them in memory, easy reuse</div></li></ul><div><br/></div><div><span style="font-weight: bold;">Virtual memory interface:
</span></div><ul><li><div>allocator interface: malloc family, mmap family</div></li><li><div>memory-mapped files
</div></li><ul><li><div>treat files as memory objects for faster IO</div></li><li><div>facilitate code sharing for programs/shared libs</div></li></ul><li><div>copy-on-write semantics
</div></li><ul><li><div>lazy copying for fork(), deduplication, checkpointing, etc.</div></li></ul><li><div>shared memory
</div></li><ul><li><div>MAP_SHARED mappings, key-based, file-based</div></li></ul><li><div>distributed shared memory
</div></li><ul><li><div>shared memory semantics over network</div></li></ul></ul><div><br/></div></body></html>