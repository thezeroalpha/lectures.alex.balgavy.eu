<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><link rel="stylesheet" href="sitewide.css"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.6 (457297)"/><meta name="altitude" content="-0.7028496265411377"/><meta name="author" content="Alex Balgavy"/><meta name="created" content="2018-12-13 13:50:34 +0000"/><meta name="latitude" content="52.33294677734375"/><meta name="longitude" content="4.864368295366129"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-12-19 00:27:28 +0000"/><title>Principles of IO hardware</title></head><body><div style="-en-paragraph:true;">IO devices available to software via an interface</div><ul><li><div style="-en-paragraph:true;">character devices: all IO occurs as <span style="text-decoration: underline;">stream</span> of bytes</div></li><li><div style="-en-paragraph:true;">block devices: all IO occurs in units of <span style="text-decoration: underline;">randomly accessible</span> blocks</div></li></ul><div style="-en-paragraph:true;"><br/></div><div style="-en-paragraph:true;">device controller</div><ul><li><div style="-en-paragraph:true;">located between actual device and computer</div></li><li><div style="-en-paragraph:true;">offers electronic interface via IO registers</div></li><li><div style="-en-paragraph:true;">R/W those registers to ask controller to perform actions</div></li></ul><div style="-en-paragraph:true;"><br/></div><div style="-en-paragraph:true;">example: parallel port</div><div style="-en-paragraph:true;"><br/></div><div style="-en-paragraph:true;"><img src="Principles%20of%20IO%20hardware.resources/screenshot.png" height="383" width="411"/></div><div style="-en-paragraph:true;"><br/></div><div style="-en-paragraph:true;"><br/></div><div style="-en-paragraph:true;">accessing IO registers</div><ul><li><div>port-mapped IO (PMIO):
</div></li><ul><li><div>IO registers are accessed via dedicated port numbers and special instructions</div></li><li><div>e.g. inb instruction</div></li></ul><li><div>memory-mapped IO (MMIO):
</div></li><ul><li><div>IO registers are mapped into address of main memory</div></li><li><div>can be accessed with a simple mov</div></li></ul><li><div>intel x86 is hybrid, does both PMIO and MMIO</div></li></ul><div style="-en-paragraph:true;"><br/></div><div style="-en-paragraph:true;">IO ports have a specification from the manufacturer (e.g. IBM PC)</div><div style="-en-paragraph:true;"><br/></div><div style="-en-paragraph:true;">waiting for requests:</div><ul><li><div>we can send commands to devices, but what if requested operation takes time?</div></li><li><div>polling:
</div></li><ul><li><div>most devices offer status bits in registers to signal that request has been finished (incl. error code)</div></li><li><div>OS can poll this status bit ("<span style="font-style: italic;">polling</span>")</div></li><li><div>is this a good solution? not a general purpose solution, but good if we know it'll complete in a short amount of time.</div></li></ul><li><div>interrupts:
</div></li><ul><li><div>device controller can trigger interrupts to signal that IO requesst is complete
</div></li><ul><li><div>for device, means changing voltage on an electrical line</div></li></ul><li><div>each controller has interrupt vector assigned
</div></li><ul><li><div>CPU runs vector-specific handler when interrupt occurs</div></li></ul><li><div>process one interrupt at a time</div></li></ul></ul><div style="-en-paragraph:true;">data exchange between device and CPU</div><ul><li><div>how do we transfer data from hard disk to memory?
</div></li><ul><li><div>program disk controller to read sector</div></li><li><div>wait for interrupt</div></li><li><div>read a device register sizeof(sector) consecutive times</div></li><li><div>repeat for next sector</div></li></ul><li><div>problem? yes sir. CPU cycles can be spent in a better way</div></li><li><div>so just let hardware do the copying -- Direct Memory Access!
</div></li><ul><li><div>on ISA systems, there was a dedicated DMA controller (third-party)</div></li><li><div>on PCI (and PCIe) systems each PCI device can become "Bus Master" and perform DMA (first-party DMA)
</div></li><ul><li><div>device and DMA controller are combined</div></li><li><div>you have to trust your hardware (or use an IO MMU)</div></li></ul><li><div>embedded systems still have dedicated DMA controller</div></li><li><div>disk controller still uses own buffers</div></li></ul></ul><div><h1><span style="font-size: 28px;"><b><br/></b></span></h1></div><div><br/></div></body></html>