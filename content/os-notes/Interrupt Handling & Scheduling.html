<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><link rel="stylesheet" href="sitewide.css"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.6 (457297)"/><meta name="altitude" content="-1.633376002311707"/><meta name="author" content="Alex Balgavy"/><meta name="created" content="2018-12-03 16:03:43 +0000"/><meta name="latitude" content="52.33331298828125"/><meta name="longitude" content="4.866615317820796"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-12-14 15:37:33 +0000"/><title>Interrupt Handling &amp; Scheduling</title></head><body><div><span style="font-weight: bold;">interrupt handling:</span></div><ul><li><div>deallocate CPU and give it to the scheduler. we rely on hardware-provided interrupt handling support (like a notification).</div></li><li><div>allows scheduler to periodically get control whenever hardware generates an interrupt</div></li><li><div>interrupt vector:
</div></li><ul><li><div>associated with each IO device and interrupt line</div></li><li><div>part of Interrupt descriptor table (IDT)</div></li><li><div>contains start address of OS-provided internal procedure</div></li></ul><li><div>interrupt handler continues execution</div></li><li><div>interrupt types: </div></li><ul><li><div>software: synchronous e.g. interrupt (int $0x80)</div></li><li><div>hardware device: asynchronous, e.g. exceptions</div></li></ul></ul><div style="-en-paragraph:true;"><span style="-en-paragraph:true;">The scheduler gets control every time an interrupt occurs. It acts as a mediator.</span></div><div style="margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"/><div style="-en-paragraph:true;"><span style="-en-paragraph:true;">What happens?</span></div><ol><li><div>Hardware puts program counter etc. on the stack</div></li><li><div>Hardware loads new program counter from interrupt vector</div></li><li><div>Assembly language procedure saves registers</div></li><li><div>Assembly language procedure sets up new stack</div></li><li><div>C interrupt service runs (e.g. reads and buffers input)</div></li><li><div>Scheduler decides which process is to run next.</div></li><li><div>C procedure returns to assembly code.</div></li><li><div>Assembly language procedure starts up new current process</div></li></ol><div><br/></div><div style="-en-paragraph:true;"><span style="-en-paragraph:true;">A process can't give the CPU to another process (i.e. do a context switch) without going through the scheduler.</span></div></body></html>