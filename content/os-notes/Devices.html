<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><link rel="stylesheet" href="sitewide.css"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.6 (457297)"/><meta name="altitude" content="-4.200446128845215"/><meta name="author" content="Alex Balgavy"/><meta name="created" content="2018-12-19 00:27:51 +0000"/><meta name="latitude" content="52.30035400390625"/><meta name="longitude" content="4.988122679323205"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-12-19 00:28:07 +0000"/><title>Devices</title></head><body><div>Solid-State Drive (SSD)<br/></div><ul><li><div>based on DRAM or NAND/NOR flash memory. no mechanical parts.</div></li><li><div>NAND flash memory</div></li><ul><li><div>organisation: cells, pages, blocks</div></li><li><div>controller can read/program by page</div></li><li><div>controller can erase by block</div></li><li><div>random/sequential access latency is comparable, but more efficient at reading than writing.</div></li></ul></ul><div><br/></div><div>Hard Disk (HDD)</div><ul><li><div>platters and cylinders in a disk, as many tracks as heads. each track has N sectors</div></li><li><div>addressing modes:</div></li><ul><li><div>CHS (cylinder-head-sector), virtual/physical</div></li><li><div>LBA (logical block addressing), only virtual</div></li></ul><li><div>in order to transfer data, you have to seek, rotate, and actually transfer. this adds up.</div></li><li><div>so how do you optimise it?</div></li><ul><li><div>aaand we’re back to scheduling. this time we’re scheduling the disk arm.</div></li><ul><li><div>first come first serve: do requests in order of arrival. but that’s not actually an optimisation.</div></li><li><div>shortest seek first: do requests with a shortest seek time. but that has to be calculated.</div></li><li><div>elevator algorithm: go up the disk, then down the disk, then back up the disk…do requests along the way.</div></li></ul></ul><li><div>error handling</div></li><ul><li><div>programming errors (if you’re requesting a nonexistent sector)</div></li><li><div>transient errors (e.g. shit getting on the head of the arm)</div></li><li><div>permanent errors (if a disk block is physically damaged)</div></li><li><div>seek errors (the arm went to the wrong place)</div></li><li><div>controller errors (controller is a lil bitch and stops accepting commands)</div></li><li><div>disk track with bad sector</div></li><ul><li><div>in this case you can remap</div></li><li><div>switch spare for bad sector, or shift all sectors to bypass the bad one</div></li></ul></ul></ul><div><br/></div><div>Clock</div><ul><li><div>Hardware function</div></li><ul><li><div>simple clocks send hardware interrupts every voltage cycle of power supply</div></li><li><div>advanced clocks have own crystal oscillator which decrements a counter in a register. send hardware interrupt every time the counter is 0</div></li></ul><li><div>Software function</div></li><ul><li><div>Maintains time of day (real time) — system boot time (backup cock) + uptime (ticks)</div></li><li><div>Stops processes from running too long — on every tick, decrement current process’ quantum</div></li><li><div>Accounts for CPU usage — on every tick, increment current process’ CPU time</div></li><li><div>Handle alarm syscall — on every tick, decrement alarm counter</div></li><li><div>Give the system watchdog/software timers — generate system notifications for synchronous alarms</div></li><li><div>Profile, monitor, gather statistics — on every tick, increment some set of counters</div></li></ul></ul><div/></body></html>