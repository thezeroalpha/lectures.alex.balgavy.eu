<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><link rel="stylesheet" href="sitewide.css"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.6 (457297)"/><meta name="altitude" content="-4.208047389984131"/><meta name="author" content="Alex Balgavy"/><meta name="created" content="2018-12-18 23:31:44 +0000"/><meta name="latitude" content="52.30032348632812"/><meta name="longitude" content="4.988162358630428"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-12-18 23:32:00 +0000"/><title>The Memory Address Space</title></head><body><div style="-en-paragraph:true;"><span style="-en-paragraph:true;">introduce abstraction of address space - every program runs in its own address space</span></div><ul><li><div>base register operates dynamic relocation, controls where address space starts</div></li><li><div>limit register decides maximum address in physical memory that you can access</div></li></ul><div><br/></div><div>how memory works with many programs:</div><ul><li><div>processes compete for memory partitions</div></li><li><div>but how do you know the size of partitions? use dynamic partitions and swapping</div><div><br/></div><div><img src="The%20Memory%20Address%20Space.resources/screenshot.png" height="264" width="590"/></div></li></ul><div><br/></div><ul><ul><li><div>problem: swapping may lead to memory fragmentation (when you have a many separate small chunks of free memory)</div></li><ul><li><div>solution: memory compaction</div></li></ul><li><div>problem - need to allow extra room for process growth</div></li><ul><li><div>how much extra room? memory usage vs out-of-memory (OOM) risk</div></li><li><div>what do when OOM (out of mana/memory)?
</div></li><ul><li><div>kill process</div></li><li><div>relocate process</div></li><li><div>swap out</div></li></ul></ul></ul></ul><div><br/></div><div>memory management
</div><ul><li><div>which part of memory is allocated?</div></li><ul><li><div>divide memory in blocks (e.g. each block is 4 bytes)</div></li><li><div>keep track of them using:</div></li><ul><li><div>bitmap</div></li><ul><li><div>divide memory in blocks. every bit in bitmap corresponds to a byte in memory. bit is 1 when the memory is allocated, 0 when it's free.</div></li><li><div>in bitmap, allocation is super fast. but to find free memory, you need to slowly scan for a hole.</div></li></ul><li><div>linked list of unallocated memory</div></li><ul><li><div>allocation is slow af, so is deallocation</div></li><li><div>holes sorted by address for fast coalescing</div></li></ul></ul></ul><li><div>how do you allocate?</div></li><ul><li><div>first fit: take first fitting hole (MINIX 3). simplest option.</div></li><li><div>next fit: take next fitting hole. slower than first fit in practice.</div></li><li><div>best fit: take best fitting hole. prone to fragmentation.</div></li><li><div>worst fit: take worst fitting hole. poor performance in practice.</div></li><li><div>quick fit: keep holes of different sizes. poor coalescing performance.</div></li><li><div>buddy allocation scheme: improve quick fit's coalescing performance (Linux uses this).
</div></li><ul><li><div>originally - area of 64 "chunks" (a unit chunk is whatever you want, on UNIX it's 4 kb)</div></li><li><div>maintain <span style="font-style: italic;">n</span> lists, one per size class</div></li><li><div>you split on powers of 2 until you get the right size</div></li><li><div>how do you find your buddies? shout eyyyyy buddy</div></li></ul></ul></ul><div/></body></html>