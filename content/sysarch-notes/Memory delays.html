<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><link rel="stylesheet" href="sitewide.css" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.13.1 (455785)"/><meta name="altitude" content="-0.1190103739500046"/><meta name="author" content="Alex Balgavy"/><meta name="created" content="2017-12-18 12:47:19 PM +0000"/><meta name="latitude" content="52.37356323888035"/><meta name="longitude" content="4.836278947153073"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-12-18 12:58:42 PM +0000"/><title>Memory delays</title></head><body><div>another cause of pipeline stalls is a delay from memory access</div><div>for example, because of a cache miss</div><div><br/></div><div>instructions:</div><div><font face="Courier New">Load R2, (R3)</font></div><div><font face="Courier New">Subtract R9, R2, #30</font></div><div><font face="Courier New"><br/></font></div><div><font face="Helvetica Neue">even if data for load is found in cache, operand forwarding can’t be done the same way — data read from cache are not available until they are in RY at start of cycle 5</font></div><div><font face="Helvetica Neue">subtract must be stalled for one cycle to delay ALU operation</font></div><div><font face="Helvetica Neue"><br/></font></div><div><img src="Memory%20delays.resources/screenshot.png" height="225" width="726"/></div><div><br/></div><div>eliminating the one-cycle stall:</div><div><div><ul><li>compiler inserts a useful instruction between load and memory-dependent instruction</li><li>otherwise, hardware stalls automatically (or compiler inserts NOP)</li></ul></div><ul/></div><div><br/></div></body></html>